<head>

<title>CS106A</title>

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta http-equiv="content-type" content="text/html; charset=UTF8">


<link href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/plugins/bootstrap-custom/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/style.css">

<!-- Java Script -->
<script src="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/plugins/jquery.min.js"></script>
<script src="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/plugins/moment.min.js"></script>
<script src="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/plugins/bootstrap-custom/js/bootstrap.min.js"></script>
<script src="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/plugins/ace/ace.js" type="text/javascript"></script>


<!-- Stanford -->
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Source+Serif+Pro:400,600,700' rel='stylesheet' type='text/css'>

</head>
<body>

	<!-- Navigation Bar -->
<nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand brand" href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184//">CS106A</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">

        <!--<li><a href="#">Lectures</a></li>-->

        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Lectures <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a><i>None yet!</i></a></li>
            <!--<li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/1-Welcome">1-Welcome</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/2-ControlFlow">2-Control Flow</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/3-Decomposition">3-Decomposition</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/4-Variables">4-Variables</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/5-ControlFlowRevisited">5-ControlFlowRevisited</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/6-SimpleJava">6-SimpleJava</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/7-Methods">7-Methods</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/8-Animation">8-Animation</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/9-Events">9-Events</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/10-References">10-References</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/11-Memory">11-Memory</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/12-TextProcessing">12-TextProcessing</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/13-Files">13-FileReading</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/14-Files+ArrayLists">14-FileReading+ArrayLists</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/106AMidtermReviewSession.pdf">Midterm Review Session</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/15-Arrays">15-Arrays</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/16-Matrix">16-Matrix</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/17-HashMaps">17-HashMaps</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/18-Interactors">18-Interactors</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/19-Classes1">19-Classes-1</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/lectures/20-Classes2">20-Classes-2</a></li>-->
          </ul>

        </li>

        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Handouts <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/1 - General Information.pdf">1 General Information</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/2 - Course Placement.pdf">2 Course Placement</a></li>
            <!--<li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/3 - Course Communication.pdf">3-Course Communication</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/4 - Honor Code.pdf">4-Honor Code</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/5 - Karel In Eclipse.pdf">5-Karel in Eclipse</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/6 - Assignment-1.pdf">6-Assignment-1</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/7 - Submitting Work.pdf">7-Submitting Work</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/8 - Karel Examples.pdf">8-Karel Examples</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/10 - Assignment-2.pdf">10-Assignment-2</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/11 - Control Statements.pdf">11-Control Statements</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/13 - Methods.pdf">13-Methods</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/15 - Assignment-3.pdf">15-Assignment-3</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/16 - Coding Style.pdf">16-Coding Style</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/17 - Variables.pdf">17-Variables</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/18 - Ufo Game.pdf">18-Ufo Game</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/19 - Strings.pdf">19-String Examples</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/20 - Assignment-4.pdf">20-Assignment 4</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/21 - Practice Midterm.pdf">21-Practice Midterm</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/22 - Exam Strategies.pdf">22-Exam Strategies</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/23 - Practice Midterm Solutions.pdf">23-Practice Midterm Solutions</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/25 - ArrayLists.pdf">25-ArrayLists</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/26 - Graphics Contest.pdf">26-Graphics Contest</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/29-assignment-5.pdf">27-Assignment 5</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/28 - Debugging.pdf">28-Debugging</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/29 - Midterm.pdf">29-Midterm</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/30 - Midterm Solutions.pdf">30-Midterm Solutions</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/31 - Assignment-6.pdf">31-Assignment 6</a></li>-->
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Assignments <span class="caret"></span></a>
          <ul class="dropdown-menu">
           
            <li><a href="https://goo.gl/forms/RjR4u0kIKY1uBQfq2">0 Who are you</a></li>
            <!--<li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/karel.html">1-Karel</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/simpleJava.html">2-Simple Java</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/breakout.html">3-Breakout</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/hangman.html">4-Hangman</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/yahtzee.html">5-Yahtzee</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/nameSurfer.html">6-NameSurfer</a></li>-->
            
            <li class="divider"></li>
            <li><a style="text-align: center;" href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/style.html">Style Guide</a></li>
            <!--

            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assignments/GraphicsContest.zip">Graphics Contest Project</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/assn/debugger.html">Extra Credit: Debugger</a></li>-->
          </ul>
        </li>

        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Sections <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a><i>None yet!</i></a></li>
            <!--<li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/9 - Section-1.pdf">Section Handout 1</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/9a - Section-1-solutions.pdf">Section 1 Solutions</a></li>
            <li class="divider"></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/12-section-2.pdf">Section Handout 2</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/12a-section-2-solutions.pdf">Section 2 Solutions</a></li>
            <li class="divider"></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/14-section-3.pdf">Section Handout 3</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/14a-section-3-solutions.pdf">Section 3 Solutions</a></li>
            <li class="divider"></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/24-section-4.pdf">Section Handout 4</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/24a-section-4-solutions.pdf">Section 4 Solutions</a></li>
            <li class="divider"></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/31-section-5.pdf">Section Handout 5</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/31a-section-5-solutions.pdf">Section 5 Solutions</a></li>
            <li class="divider"></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/Section-6.pdf">Section Handout 6</a></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/Section-6-solutions.pdf">Section 6 Solutions</a></li>
            <li class="divider"></li>
            <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/handouts/Section-7.pdf">Section Handout 7</a></li>


            <li class="divider"></li>

            <li><a href="https://cs198.stanford.edu/cs106/auth/section/ViewSections.aspx?class=1">List of all section times/locations</a></li>-->
          </ul>
        </li>

        <!--<li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Tools <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="">Nothing Yet</a></li>
          </ul>
        </li>-->
       
      </ul>

      <ul class="nav navbar-nav navbar-right">
        <li><a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/schedule.html"><span class="glyphicon glyphicon-th-large" aria-hidden="true"></span> Schedule</a></li>
      </ul>
      
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

	<div class="container">
			
		<!-- Header -->
		<div class="row">
			<div class="col-sm-12">
				<div id="pageHeader">
					<h1>
						Anagrams and Bananagrams
					</h1>
					
					<p>
						Written by Chris Piech
					</p>

					<p>
						<p class="subtleHeading">January 13th, 2016</p>
					</p>

				</div>
				<hr/>
			</div>
		</div>



		<!-- Main Image -->
		<div class="row">
			<div class="col-sm-12">
				<p>
					This handout does two things. First it goes over the anagram example from lecture. Then I present the first ever (to the best of my knowledge) AI solver for Bananagrams
				</p>
				<center>
					<img src = "//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184/img/handouts/banana/banana.jpg" style="max-width:80%"></img>
				</center>
				<center>
					<i>Bananagrams, which builds off of Anagrams</i>
				</center>
				<p></p>
				<hr/>
			</div>
		</div>

		

		<div class="row">
			<div class="col-sm-12">
				<h2>Ananagrams</h2>
				<p> In class we solved this particularly interesting poblem: Write a program to find all anagrams of a word the user types. You may use a file which contains all english words.

				</p>
                <p>
                    To find all anagrams of a word we used a function <code>sortLetters(str)</code> that took a string and would return the same string with all of its letters in sorted order. Lets call the returned string the key. We realized that this was particularly useful because it is always true that:
                </p>
                <p>
                    If two words are anagrams calling <code>sortLetters</code> on both words will always return the same key.
                </p>

                <p>
                    If two words are not anagrams calling <code>sortLetters</code> on both words will return two distinct keys.
                </p>
                <p>
                    From that point, our strategy was to employ our new tool <code>Map</code>. We built a map that related every key to the set of all words in English that you could form with the letters in that key. It was amazingly fast. Here is the code:
                </p>

                <p>
                    <pre class="editor">string sortLetters(string s);

int main() {
    cout << "Anagrams" << endl;

    Map&lt;string, Set&lt;string> > anagram;

    ifstream input;
    openFile(input, "scrabble-dictionary.txt");
    string line;
    while(getline(input, line)) {
        string word = trim(toLowerCase(line));
        string sorted = sortLetters(word);
        anagram[sorted].add(word);
    }

    // repeatedly prompt the user for words to look up in the map
    while (true) {
        string word = toLowerCase(getLine("Type a word [or Enter to quit]: "));
        if (word == "") {
            break;
        } else {
            string sorted = sortLetters(word);
            for(string found : anagram[sorted]) {
                cout << found << endl;
            }

        }
    }

    return 0;
}

/*
 * Returns a canonical version of the given word
 * with its letters arranged in alphabetical order.
 * For example, sortLetters("banana") returns "aaabnn".
 * This code was provided by the instructor as-is; we didn't write it in class.
 */
string sortLetters(string s) {
    sort(s.begin(), s.end());   // sort function comes from C++ STL libraries
    return s;
}
                    </pre>
                </p>

				<hr/>

				<h2>Bananagrams</h2>
                <p>Anagrams was <i>fast</i>. So fast in fact that it inspired me to use it to solve an even bigger problem. I dig the game <a href="https://en.wikipedia.org/wiki/Bananagrams">Banangrams</a> so I thought it would be cool to have a computer that could play it. If you don't know Banangrams head to the book store, buy a copy, take a few late days on your assignment and figure it out (kidding).</p>

                <p>
                    On some level Banangrams is a hard problem. There are so many potential ways of laying out tiles on a grid that it could take the lifetime of the universe to try them all. To make the problem easier I formulated my solution as: (A) Come up with the best first word possible using <a href="https://en.wikipedia.org/wiki/Heuristic">heuristics</a> then (B) assume that is fixed and try and place your remaining tiles. It worked! Here are two example games with the tiles the AI was presented with, and the boards it discovered:
                </p>

                <p>
                    <img src = "//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184//img/handouts/banana/example.png" style="width:100%"></img>
                </p>

                <p>
                    Getting the best first word (similar to getting subsequent good words) is hard. You really want to try all combinations of including and excluding tiles. To solve this problem I used a thought process called Breadth First Search, which is similar to how you are going to solve Word Ladder.
                </p>
				<p>Bellow is the code. You can also peruse <a href="//web.stanford.edu/class/archive/cs/cs106a/cs106a.1184//lectures/4-MapsSets/code/bananagrams/src/banagrams.cpp">bananagrams.cpp</a> if you want it as a file. I would consider this an example of CS106B expectations for style.
					The functions are generally bite size and nicely decompose the hard problem into smaller pieces. Functions are
				    well named and have comments. I use const int instead of raw "magic" numbers. Enjoy.</p>
				<pre class="editor">/*
 * CS 106B, Chris Piech
 * I had this need to program. And then while getting ready for lecture 4 I realized
 * there was no published AI solver for Bananagrams:
 * https://en.wikipedia.org/wiki/Bananagrams
 * So here you have it. The (as far as I know) first computer bananagram agent.
 *
 * When reading this I suggest:
 *  0. Check out main
 *  1. Check out the game setup
 *  2. Check out getFirstWord
 *  3. Check out playWordOnBoard
 *
 * All the best,
 * Chris Piech (piech@cs.stanford.edu)
 */

#include &lt;fstream>
#include &lt;iostream>
#include &lt;iomanip>
#include "console.h"
#include "timer.h"
#include "hashset.h"
#include "lexicon.h"
#include "queue.h"
#include "set.h"
#include "vector.h"
#include "grid.h"
#include "filelib.h"
#include "gwindow.h"
#include "gobjects.h"
#include "simpio.h"

using namespace std;

// How many tiles each player draws at the start
const int NUM_START_TILES = 21;
// How big to make the virtual grid that I populate
const int MAX_BOARD_SIZE = NUM_START_TILES * 2;
// Bananagrams is a complex game. Limit how deep we go
const int MAX_WORDS_PER_SPOT = 300000;
// How big should the tiles be in visualization
const int TILE_SIZE = 50;
// Some constants to store directions
const int LEFT_RIGHT = 0;
// Some constants to store directions
const int UP_DOWN = 1;

/**
 * Struct: Spot
 * This is the one C++ thing I used that we haven't seen.
 * It basically packages a row, col and direction into 
 * a single, simple, variable type called Spot. I'll cover
 * this on Friday.
 */
struct Spot {
    int r;
    int c;
    int dir;
};

/**
 * Struct: Utilities
 * This variable type packages the reverseMap and the tile
 * letterScores into one variable for shorter parameter 
 * lists.
 */
struct Utils {
    Map&lt;string, Set&lt;string>> anagramMap;
    Map&lt;char, int> letterScores;
};

// Artificial Intelligence Part
string getWordToPlay(Utils & utils, string & tiles, string seed);
string playWordOnBoard(Utils & utils, string & tiles, Grid&lt;char> & board);
string checkForWord(Utils & utils, string & tiles);
int getHeuristic(Utils & utils, string str, string seed);
Vector&lt;Spot> getSpots(Grid&lt;char> & board, int spacing);

// First Word Functions
string getFirstWord(Utils & utils, string & tiles);
void placeFirstWordOnBoard(Grid&lt;char> & board, string& word);

// Helper Functions
string sortLetters(string s);
void removeTiles(string & tiles, string playedWord);
int countLetters(string & str);
void orientWord(Grid&lt;char> & board, Spot spot, string word);

// Game Setup
string setUpUtils(Utils & utils);
string loadLetters();
void populateAnagramMap(Lexicon &lexicon, Map&lt;string, Set<string> > &anagram);
string selectRandomTiles(string & pile, int num);
Grid&lt;char> makeBoard();

// Board Visualization
Grid&lt;char> getTrimmedBoard(Grid&lt;char> & board);
void visualizeBoard(Grid&lt;char> & board);
void outputTrimmedBoard(Grid&lt;char> & board);

/* Main
 * Selects 21 random tiles and plays them in a grid. It doesn't
 * work perfectly but plays all tiles about 90% of the time...
 * This is just the start..
 */
int main() {
    // Remove this to add some randomness. Keep for debugging.
    setRandomSeed(0);

    // 0. Setup the game
    Utils utils;
    string allTiles = setUpUtils(utils);
    string playerTiles = selectRandomTiles(allTiles, 21);
    Grid&lt;char> board = makeBoard();

    cout << "Original Tiles: " << playerTiles << endl;
    getLine("Press enter to run:");

    // 1. Play the first word
    string first = getFirstWord(utils, playerTiles);
    placeFirstWordOnBoard(board, first);
    outputTrimmedBoard(board);
    removeTiles(playerTiles, first);
    cout << "remaining tiles: " << playerTiles << endl;

    // 2. Play the remaining words
    while(true) {
        if(playWordOnBoard(utils, playerTiles, board) == "") break;
        outputTrimmedBoard(board);
        cout << "remaining tiles: " << playerTiles << endl;
    }

    // 3. Show the user
    visualizeBoard(board);
    cout << "Thanks for playing" << endl;
    return 0;
}

/*********************************************************************
 *                          SETUP                                    *
 *********************************************************************/

/* Make Board
 * Make a really large empty board. Make it so big that if we start in
 * the middle no combination of words could take us off the board.
 * Later when visualizing the board we can trim it.
 */
Grid&lt;char> makeBoard() {
    Grid&lt;char> board(MAX_BOARD_SIZE,MAX_BOARD_SIZE);
    for(int r = 0; r < MAX_BOARD_SIZE; r++){
        for(int c = 0; c < MAX_BOARD_SIZE; c++) {
            board[r][c] = ' ';
        }
    }
    return board;
}

/* Score Letter
 * If I submitted this code, I might lose a style bucket for this method.
 * There are a bunch of what we call "magic" numbers... numbers which are
 * constant but have no explained meaning. This function takes a character,
 * and how many times it shows up in the game and scores how hard it is
 * to play.
 */
int scoreLetter(char ch, int count) {
    if(ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {
        return 1;             // Oops magic numbers. Minus style point.
    }
    if(count <= 2) return 40; // Oops magic numbers. Minus style point.
    if(count <= 4) return 10; // Oops magic numbers. Minus style point.
    if(count <= 9) return 5;  // Oops magic numbers. Minus style point.
    return 3;                 // Oops magic numbers. Minus style point.
}

/* Load Letter Scores
 * This creates a mapping between each letter and how useful
 * I think it is to play that letter. In the world of AI we call
 * these scores "heuristics". For example I think its really good
 * to play an X, and not nearly as good to play an A. I base these
 * scores off of how frequent the letters show up in the game.
 */
void loadLetterScores(Map&lt;char, int> & scores) {
    ifstream countStream;
    openFile(countStream, "banana-dist.txt");
    for(char ch = 'A'; ch <= 'Z'; ch++) {
        string countStr;
        getline(countStream, countStr);
        int count = stringToInteger(countStr);
        int letterScore = scoreLetter(ch, count);
        scores[ch] = letterScore;
    }
}

/* Set Up Utils
 * This function loads the scrabble dictionary, the map
 * of letter scores (the "scores" are made up by Chris and
 * are not part of the game rules) and the game tiles.
 */
string setUpUtils(Utils & utils) {
    cout << "Bananagrams" << endl;
    Lexicon english("scrabble-dictionary.txt");
    populateAnagramMap(english, utils.anagramMap);
    loadLetterScores(utils.letterScores);
    return loadLetters();
}

/* Load Letters
 * Bananagrams uses a carefully chosen count of tiles. I looked
 * up those counts and put them in the file banana-dist.txt. This
 * function reads that file and returns all the tiles as one long
 * string.
 */
string loadLetters() {
    string letters;
    ifstream countStream;
    openFile(countStream, "banana-dist.txt");
    for(char ch = 'A'; ch <= 'Z'; ch++) {
        string countStr;
        getline(countStream, countStr);
        int count = stringToInteger(countStr);
        for(int i = 0; i < count; i++) {
            letters += ch;
        }
    }
    return letters;
}

/* Populate Anagram Map
 * Just like in the example we saw in class. We keep a map of sortedLetters
 * to all the words that those letters can be re-arranged to spell.
 */
void populateAnagramMap(Lexicon &lexicon, Map&lt;string, Set&lt;string> > &anagram) {
    for(string word : lexicon) {
        word = toUpperCase(word);
        string sorted = sortLetters(word);
        anagram[sorted].add(word);
    }
}

/* Select Random Tiles
 * Given a pile of tiles, randomly select num of them without
 * replacement. Return the selected tiles.
 */
string selectRandomTiles(string & pile, int num) {
    string selected;
    for(int i = 0; i < num; i++) {
        int index = randomInteger(0, pile.length() - 1);
        char tile = pile[index];
        pile.erase(index, 1);
        selected += tile;
    }
    return selected;
}

/*********************************************************************
 *                       FIRST WORD                                  *
 *********************************************************************/

/* Get First Word
 * Chose a first word to play given your tiles. All of the logic here
 * is deffered to the function getWordToPlay which can take a seed (aka
 * a letter to play off). At the start there is no seed.
 */
string getFirstWord(Utils & utils, string & tiles) {
    return getWordToPlay(utils, tiles, "");
}

/* Place First Word on Board
 * Put it right in the middle. If we make the board at least 2N x 2N
 * where N is the number of tiles to play this should always be safe.
 */
void placeFirstWordOnBoard(Grid&lt;char> &board, string& first){
    for(int i = 0; i < first.size(); i++) {
        int col = MAX_BOARD_SIZE/2 + i;
        board[MAX_BOARD_SIZE/2][col] = first[i];
    }
}

/*********************************************************************
 *                       A.I. PART                                   *
 *********************************************************************/

/* Get Word To Play
 * This function is the heart of the AI. It tries to find the best word
 * it can possibly play using a set of tiles and building off of a
 * seed (which is often the empty string or a single character). It
 * wants to call checkForWord with every possible combination of letters
 * in tiles. To try every combination of letters I use a Queue called
 * pipeline. In pipeline I keep all the combinations of tiles I have used
 * so far. At first I just put the seed in the pipeline. Then each step
 * through the pipeline I pull out the next combination of letters to
 * check... and then
 *    1. I check if I can make a better word using those letters
 *    2. I enqueue two extra combinations.
 *        2a. One with the next tile
 *        2b. One without the next tile
 * If you think it through this will eventually try every combination
 * of tiles. This is a *very* advanced use of queues and I don't expect
 * everyone in CS106B to get it just by reading the code. But please do ask
 * if you want to know more.
 */
string getWordToPlay(Utils & utils, string & tiles, string seed) {
    string best = "";
    int bestScore = 0;
    // A collection of things to try
    Queue&lt;string> pipeline;

    // Initially we are going to start with the seed
    pipeline.enqueue(seed);
    int done = 0;
    while(!pipeline.isEmpty()) {
        // Get the next combination of tiles to try.
        string soFar = pipeline.dequeue();

        // How great would it be if we could make a word?
        int score = getHeuristic(utils, soFar, seed);
        if(score > bestScore) { // Very
            string word = checkForWord(utils, soFar);
            // We found a word thats better than previous best
            if(word != "") {
                bestScore = score;
                best = word;
                cout << best  << endl;
            }
        }

        // What is the next tile to include or exclude?
        int index = soFar.length() - seed.length();
        if(index < tiles.length()) {
            // Try including it (will be dequeued later)
            string a = soFar + tiles[index];
            pipeline.enqueue(a);
            // Try excluding it (will be dequeued later)
            string b = soFar + '-';
            pipeline.enqueue(b);
        }

        // Sometimes you have searched deep enough...
        if(++done == MAX_WORDS_PER_SPOT) break;
    }
    return best;
}

/* Play Word On Board
 * First find all spots where you could potentially play all of your tiles
 * in terms of spacing. Then for each of those spots find the best word you
 * could play in terms of actual english words. Finally play your best move!
 */
string playWordOnBoard(Utils & utils, string & tiles, Grid&lt;char> & board) {
    Spot bestSpot;
    string best = "";
    int bestScore = 0;

    // Check each spot
    Vector&lt;Spot> playableSpots = getSpots(board, tiles.size());
    for(Spot spot : playableSpots) {
        string seed = charToString(board[spot.r][spot.c]);
        string word = getWordToPlay(utils, tiles, seed);
        if(word != "") {
            int score = getHeuristic(utils, word, seed);
            if(score > bestScore) {
                bestSpot = spot;
                bestScore = score;
                best = word;
            }
        }
    }

    // Play your best move
    if(best != "") {
        string seed = charToString(board[bestSpot.r][bestSpot.c]);
        string used = best;
        used.erase(used.find(seed), 1);
        removeTiles(tiles, used);
        orientWord(board, bestSpot, best);
    }
    return best;
}

/* Check For Word
 * This is that same funcition that we wrote in class for the
 * anagrams problem! It uses the anagramMap which maps from
 * sortedLetters to a set of all words you can make with those
 * letters. Its super fast. Returns a word if found. Empty string
 * otherwise.
 */
string checkForWord(Utils & utils, string & tiles) {
    string base = "";
    for(int i = 0; i < tiles.size(); i++) {
        if(tiles[i] != '-') base += tiles[i];
    }
    base = toUpperCase(base);
    string baseSorted = sortLetters(base);
    if(utils.anagramMap.containsKey(baseSorted)) {
        return utils.anagramMap[baseSorted].first();
    }
    return "";
}

/* Get Heuristic
 * How awesome would it be if we played this word?
 */
int getHeuristic(Utils & utils, string str, string seed) {
    int score = 0;
    for(int i = seed.length(); i < str.length(); i++) {
        if(str[i] != '-') {
            char ch = str[i];
            score += utils.letterScores[ch];
        }
    }
    return score;
}

/* Check Left Right Spacing
 * Would there be enough spacing to place all of our letters at this spot
 * left-to-right regardless of how it latches on. This hasn't been
 * thoroughly tested.
 */
bool checkLeftRightSpacing(Grid&lt;char> & board, int r, int c, int spacing) {
    for(int dRow = -1; dRow <= +1; dRow++) {
        for(int dCol = -spacing; dCol <= +spacing; dCol++) {
            int currCol = c + dCol;
            int currRow = r + dRow;
            if(board[currRow][currCol] != ' ' && currCol != c) return false;
            if(board[currRow][currCol] && currCol == c && abs(dCol) == spacing){
                return false;
            }
        }
    }
    return true;
}

/* Check Up Down Spacing
 * Would there be enough spacing to place all of our letters at this spot
 * up-to-down regardless of how it latches on. This hasn't been
 * thoroughly tested.
 */
bool checkUpDownSpacing(Grid&lt;char> & board, int r, int c, int spacing) {
    for(int dCol = -1; dCol <= +1; dCol++) {
        for(int dRow = -spacing; dRow <= +spacing; dRow++) {
            int currRow = r + dRow;
            int currCol = c + dCol;
            if(board[currRow][currCol] != ' ' && currRow != r) return false;
            if(board[currRow][currCol] && currRow == r && abs(dRow) == spacing){
               return false;
            }
        }
    }
    return true;
}

/* Get Spots
 * Find all board locations (with direction) where you could safely play
 * any word without worrying about running into another word.
 */
Vector&lt;Spot> getSpots(Grid&lt;char> & board, int spacing) {
    Vector&lt;Spot> spots;
    for(int r = 0; r < board.numRows(); r++) {
        for(int c = 0; c < board.numCols(); c++) {
            if(board[r][c] != ' ') {
                if(checkLeftRightSpacing(board, r, c, spacing)) {
                    Spot found = {r,c,LEFT_RIGHT};
                    spots.add(found);
                }
                if(checkUpDownSpacing(board, r, c, spacing)) {
                    Spot found = {r,c,UP_DOWN};
                    spots.add(found);
                }
            }
        }
    }
    return spots;
}



/*********************************************************************
 *                     HELPER FUNCTIONS                              *
 *********************************************************************/

/* Sort Letters
 * Returns a canonical version of the given word
 * with its letters arranged in alphabetical order.
 * For example, sortLetters("banana") returns "aaabnn".
 * This code was provided by the instructor as-is; we didn't write it in class.
 */
string sortLetters(string s) {
    sort(s.begin(), s.end());   // sort function comes from C++ STL libraries
    return s;
}

/* Remove Tiles
 * Assumes that tiles is a string of tiles that you can play
 * and that you just played the string playedWord. Removes each
 * of the letters in playedWord from tiles.
 */
void removeTiles(string & tiles, string playedWord) {
    playedWord = toUpperCase(playedWord);
    for(int i = 0; i < playedWord.size(); i++) {
        if(playedWord[i] == '-') continue;
        int tileIndex = tiles.find(playedWord[i]);
        tiles.erase(tileIndex, 1);
    }
}

/* Count Letters
 * Given a string that is composed of letters and dashes,
 * eg: AB--C--D--
 * Count how many letters the are. Above would return 4.
 */
int countLetters(string & str) {
    int count = 0;
    for(int i = 0; i < str.length(); i++) {
        if(str[i] != '-') {
            count++;
        }
    }
    return count;
}

/* Orient Word
 * You found a spot, and you know what word you want to play
 * in that spot. This method places the word on the grid.
 */
void orientWord(Grid&lt;char> & board, Spot spot, string word) {
    char seed = board[spot.r][spot.c];
    int index = word.find(seed);
    if(spot.dir == LEFT_RIGHT) {
        int startCol = spot.c - index;
        for(int i = 0; i < word.size(); i++) {
            int c = i + startCol;
            board[spot.r][c] = word[i];
        }
    }
    if(spot.dir == UP_DOWN) {
        int startRow = spot.r - index;
        for(int i = 0; i < word.size(); i++) {
            int r = i + startRow;
            board[r][spot.c] = word[i];
        }
    }
}

/*********************************************************************
 *                   BOARD VISUALIZATION                             *
 *********************************************************************/

/* Visualize Board
 * Draw a board of characters onto the screen. First trims it so
 * that there isn't a lot of empty white space.
 */
void visualizeBoard(Grid&lt;char> & board) {
    Grid&lt;char> trimmed = getTrimmedBoard(board);
    int width = TILE_SIZE * trimmed.numCols();
    int height = TILE_SIZE * trimmed.numRows();
    GWindow gw(width, height);
    for(int r = 0; r < trimmed.numRows(); r++) {
        for(int c = 0; c < trimmed.numCols(); c++) {
            if(trimmed[r][c] != ' ') {
                int x = TILE_SIZE * c;
                int y = TILE_SIZE * r;
                GRect * rect = new GRect(x, y, TILE_SIZE, TILE_SIZE);
                rect->setColor("#4E3520");
                rect->setFillColor("#EBCD9F");
                rect->setFilled(true);

                string tile = charToString(trimmed[r][c]);
                GLabel * label = new GLabel(tile);
                label->setFont("SansSerif-24");
                int labelX = x + (TILE_SIZE - label->getWidth())/2;
                int labelY = y + (TILE_SIZE + label->getFontAscent())/2;

                gw.add(rect);
                gw.add(label, labelX, labelY);
            }
        }
    }
}

/* Output Trimmed Board
 * Cout a board of characters onto the console. First trims it so
 * that there isn't a lot of empty white space.
 */
void outputTrimmedBoard(Grid&lt;char> & board) {
    Grid&lt;char> trimmed = getTrimmedBoard(board);

    cout << "----------" << endl;
    for(int r = 0; r < trimmed.numRows(); r++) {
        for(int c = 0; c < trimmed.numCols(); c++) {
            cout << trimmed[r][c];
        }
        cout << endl;
    }
    cout << "----------" << endl;
}

/* Get Trimmed Board
 * Trims a board of characters so that there isn't
 * a lot of empty white space.
 */
Grid&lt;char> getTrimmedBoard(Grid&lt;char> & board) {
    int minC = board.numCols() - 1;
    int maxC = 0;
    int minR = board.numRows() - 1;
    int maxR = 0;
    for(int r = 0; r < board.numRows(); r++) {
        for(int c = 0; c < board.numCols(); c++) {
            if(board[r][c] != ' ') {
                minC = min(minC, c);
                minR = min(minR, r);
                maxC = max(maxC, c);
                maxR = max(maxR, r);
            }
        }
    }
    Grid&lt;char> trimmed(maxR - minR + 1, maxC - minC + 1);
    for(int r = 0; r < trimmed.numRows(); r++) {
        for(int c = 0; c < trimmed.numCols(); c++) {
            trimmed[r][c] = board[minR + r][minC + c];
        }
    }
    return trimmed;
}
</pre>
			</div>
		</div>
		
		
				
		


	



<div class="row">
	<div class="col-md-12">
		<hr>

		<div class="footer">
			<p class="pull-left">
				&#169; Stanford 2017 &#124; Created by Chris Piech.
				CS106A has been developed over decades by many talented teachers. 
			</p>
		</div>
	</div>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74362126-1', 'auto');
  ga('send', 'pageview');

</script>

	</div>

	<script>
		$('.editor').each(function( index ) {
			var editor = ace.edit(this);
			editor.setTheme('ace/theme/eclipse');
		   editor.getSession().setMode("ace/mode/c_cpp");
		   editor.setReadOnly(true);
		   editor.setShowPrintMargin(false);
		   editor.renderer.setShowGutter(false); 
		   editor.setOptions({
			    maxLines: Infinity,
			    fontSize: "10pt"
			});
		   editor.setOption("highlightActiveLine", false);
		});
	</script>

</body>
